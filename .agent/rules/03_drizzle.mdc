---
description: EstÃ¡ndares Drizzle ORM
globs: ["lib/db/**/*.ts", "drizzle.config.ts"]
---

# ğŸ—ƒï¸ Reglas Drizzle ORM

Aplican a todos los archivos en `lib/db/` y `drizzle.config.ts`.

---

## ğŸ“ Naming Conventions

| Elemento | ConvenciÃ³n | Ejemplo |
|----------|------------|---------|
| Tablas | snake_case (plural) | `users`, `user_sessions` |
| Columnas | snake_case | `created_at`, `user_id` |
| Variables TS | camelCase | `users`, `userSessions` |
| Foreign Keys | `<tabla>_<columna>_fk` | `users_org_id_fk` |
| Ãndices | `<tabla>_<columna>_idx` | `users_email_idx` |

---

## ğŸ—ï¸ Estructura de Schema

```typescript
// lib/db/schema/users.ts

import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: uuid("id").defaultRandom().primaryKey(),
  email: text("email").notNull().unique(),
  name: text("name"),
  role: text("role", { enum: ["admin", "user"] }).default("user"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Exportar tipos inferidos
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
```

---

## ğŸ”„ Migraciones

### Flujo de cambios en schema

```bash
# 1. Modificar schema en lib/db/schema/
# 2. Generar migraciÃ³n (nombre descriptivo)
pnpm db:generate

# 3. Revisar migraciÃ³n generada en drizzle/
# 4. Aplicar a desarrollo
pnpm db:push

# 5. Commit de schema + migraciÃ³n juntos
```

### âŒ Nunca

- Editar migraciones ya aplicadas en producciÃ³n
- Usar `db:push` en producciÃ³n (solo `db:migrate`)
- Borrar migraciones sin documentar

---

## ğŸ” Queries

### PatrÃ³n recomendado

```typescript
// âœ… Query con relaciones
const userWithOrg = await db.query.users.findFirst({
  where: eq(users.id, userId),
  with: {
    organization: true,
  },
});

// âœ… Select especÃ­fico (mejor performance)
const userEmail = await db
  .select({ email: users.email })
  .from(users)
  .where(eq(users.id, userId));
```

### âŒ Evitar

```typescript
// âŒ Select * implÃ­cito cuando no se necesita todo
const user = await db.select().from(users);

// âŒ N+1 queries
for (const user of users) {
  const org = await db.query.organizations.findFirst({
    where: eq(organizations.id, user.orgId),
  });
}
```

---

## ğŸ” Seguridad

### ValidaciÃ³n obligatoria

```typescript
// âœ… Siempre validar antes de insertar
const parsed = insertUserSchema.safeParse(input);
if (!parsed.success) throw new Error("Invalid data");

await db.insert(users).values(parsed.data);
```

### Soft deletes (recomendado)

```typescript
// âœ… Preferir soft delete para datos importantes
export const users = pgTable("users", {
  // ...
  deletedAt: timestamp("deleted_at"),
});

// Query excluyendo borrados
const activeUsers = await db.query.users.findMany({
  where: isNull(users.deletedAt),
});
```

---

## ğŸ“Š Ãndices

Crear Ã­ndices para:
- Columnas usadas en `WHERE` frecuentemente
- Foreign keys
- Columnas con `UNIQUE` constraint

```typescript
export const users = pgTable("users", {
  email: text("email").notNull(),
  orgId: uuid("org_id").references(() => organizations.id),
}, (table) => ({
  emailIdx: uniqueIndex("users_email_idx").on(table.email),
  orgIdIdx: index("users_org_id_idx").on(table.orgId),
}));
```
